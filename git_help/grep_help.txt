Використання: grep [OPTION] ... PATTERN [ФАЙЛ] ...
Шукайте PATTERN у кожному файлі.
Приклад: grep -i 'hello world' menu.h main.c

Вибір і інтерпретація шаблонів:
-E, --extended-regexp PATTERN - це розширений регулярний вираз
-F, --fixed-strings PATTERN - це набір рядків, розділених новим рядком
-G, --basic-regexp PATTERN - це основний регулярний вираз (за замовчуванням)
-P, --perl-regexp PATTERN є регулярним виразом Perl
-e, --regexp = PATTERN використовує PATTERN для відповідності
-f, --file = FILE отримують PATTERN з FILE
-i, - ігнорувати відмінності випадків
-w, --word-regexp примушує PATTERN відповідати тільки цілим словам
-x, --line-regexp примушує PATTERN відповідати тільки цілим рядкам
-z, --null-дані, лінія даних закінчується 0 байтом, а не рядком нового рядка

Різне:
-s, --no-messages припиняють повідомлення про помилки
-v, --invert-match вибір невідповідних рядків
-V, --version показують інформацію про версію і виходять
--help відобразити цей текст довідки і вийти

Керування виходом:
-m, --max-count = NUM ​​зупиняється після NUM вибраних рядків
-b, --byte-offset друкують зміщення байта з вихідними лініями
-n, --line-number номер рядка друку з вихідними лініями
- вирівнювання флеш-буферу на кожному рядку
-H, --with-filename, ім'я файлу друку з вихідними лініями
-h, --no-filename пригнічує префікс імені файлу на виході
--label = LABEL використовують LABEL як стандартний префікс імені файлу вводу
-o, --only-matching показують лише частину рядка, що відповідає PATTERN
-q, --quiet, --silent пригнічують весь нормальний вихід
--binary-files = TYPE припускають, що двійкові файли TYPE;
TYPE - "двійковий", "текст" або "без відповідності"
-a, - еквівалент тексту -binary-files = text
-I еквівалент -binary-files = без відповідності
-d, --directories = ACTION, як обробляти каталоги;
ACTION "прочитано", "рекурсивно" або "пропущено"
-D, --devices = ACTION, як обробляти пристрої, FIFO і розетки;
ACTION "прочитано" чи "пропущено"
-r, - рекурсивний подібний --directories = recurse
-R, --референційно-рекурсивний аналогічно, але слідують всім посиланням
--include = FILE_PATTERN шукати тільки файли, які відповідають FILE_PATTERN
--exclude = FILE_PATTERN пропускає файли та каталоги, що відповідають FILE_PATTERN
--exclude-from = ФАЙЛ пропускати файли, що відповідають будь-якому файлу з FILE
--exclude-dir = каталоги PATTERN, які відповідають PATTERN, будуть пропущені.
-L, --файли без відповідності друкують лише імена файлів без виділених рядків
-l, --files-with-matches, друкувати тільки імена файлів з вибраними рядками
-c, --count друкує тільки кількість вибраних рядків на ФАЙЛ
-T, вкладка "Початок"
-Z, --null друкує 0 байт після імені FILE

Контроль контексту:
-B, --before-context = NUM ​​друк, NUM рядків провідного контексту
-A, -fter-context = NUM ​​друк, NUM рядків кінцевого контексту
-C, --context = NUM ​​print, NUM рядків вихідного контексту
-NUM те ж, що і --context = NUM
--color [= WHEN]
--colour [= WHEN] використовують маркери для виділення відповідних рядків;
WHEN є "завжди", "ніколи" або "авто"
-U, --binary не видаляє символи CR на EOL (MSDOS / Windows)

Якщо FILE має значення "-", прочитайте стандартний вхід. Без файлу FILE прочитано "." якщо
рекурсивний, '-' інакше. Маючи менше двох файлів, припустимо -h.
Статус виходу - 0, якщо вибрано будь-який рядок, - 1 інакше;
якщо виникає помилка і -q не задано, статус виходу 2.

Повідомте про помилки за адресою: bug-grep@gnu.org
Домашня сторінка GNU grep: <http://www.gnu.org/software/grep/>
Загальна допомога з використанням програмного забезпечення GNU: <http://www.gnu.org/gethelp/>